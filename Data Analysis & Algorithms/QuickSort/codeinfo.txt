Perfect ğŸ‘ letâ€™s now connect everything from theory to your actual **Java code** step by step â€” like mapping every block of logic to what it does conceptually.

---

## ğŸ§© Structure overview of your program

Your program has **two main parts**:

1. **QuickSort logic**

   * Deterministic version (fixed pivot = last element)
   * Randomized version (pivot chosen randomly)
2. **Main function**

   * Takes input from user
   * Makes two copies of array
   * Sorts one using deterministic, the other using randomized
   * Prints both sorted arrays and their execution times

---

## ğŸ”¹ Step 1: Deterministic QuickSort

```java
static void deterministicQuickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        deterministicQuickSort(arr, low, pivotIndex - 1);
        deterministicQuickSort(arr, pivotIndex + 1, high);
    }
}
```

**Meaning line-by-line:**

* `if (low < high)` â†’ base condition of recursion.
  If the subarray has 0 or 1 elements, itâ€™s already sorted â€” stop.

* `int pivotIndex = partition(arr, low, high);`
  Calls the **partition** function, which:

  * Picks the last element as pivot (`arr[high]`),
  * Rearranges array so all smaller elements are on left,
  * Returns the final index of pivot.

* Then recursively call `deterministicQuickSort`:

  * Left side of pivot â†’ `low` to `pivotIndex - 1`
  * Right side of pivot â†’ `pivotIndex + 1` to `high`

This is the **divide-and-conquer** step â€” divide around pivot, conquer (sort) both sides.

---

## ğŸ”¹ Step 2: Partition logic (heart of QuickSort)

```java
static int partition(int[] arr, int low, int high) {
    int pivot = arr[high];   // choose last element as pivot
    int i = low - 1;         // index of smaller element

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr, i, j);
        }
    }

    swap(arr, i + 1, high);  // place pivot in correct position
    return i + 1;            // return index of pivot
}
```

### Visual meaning:

Say the subarray is `[8, 4, 7, 3, 10, 5]`.

* pivot = 5
* `i = low - 1` â†’ starts before first element.
* `for` loop moves through all elements before pivot:

  * If `arr[j] < pivot`, move it left (swap with element after `i`).
  * So after loop: everything left of `i` is `< pivot`.
* Finally, swap pivot with `arr[i+1]` to put it between smaller and larger elements.

Return `i+1` = the new **pivot index**.

---

## ğŸ”¹ Step 3: Randomized QuickSort

```java
static void randomizedQuickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = randomizedPartition(arr, low, high);
        randomizedQuickSort(arr, low, pivotIndex - 1);
        randomizedQuickSort(arr, pivotIndex + 1, high);
    }
}
```

Itâ€™s the **same structure** as deterministic version â€” only the pivot selection changes.

---

## ğŸ”¹ Step 4: Randomized Partition

```java
static int randomizedPartition(int[] arr, int low, int high) {
    int randomPivot = low + (int)(Math.random() * (high - low + 1));
    swap(arr, randomPivot, high); // move random pivot to end
    return partition(arr, low, high);
}
```

### Step-by-step:

1. Picks a random pivot index between `low` and `high`.
2. Swaps that random pivot element with the last element.
3. Calls the **same partition()** function, which always expects pivot at the end.

ğŸ‘‰ So effectively, youâ€™re just randomizing *which* element becomes the pivot each time â€” all other logic is reused.

---

## ğŸ”¹ Step 5: Swap function

```java
static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

A simple helper that exchanges two elements.
Used in partitioning and random pivot selection.

---

## ğŸ”¹ Step 6: printArray function

```java
static void printArray(int[] arr) {
    for (int val : arr)
        System.out.print(val + " ");
    System.out.println();
}
```

Just loops through all elements of the array and prints them in one line.

---

## ğŸ”¹ Step 7: Main function

```java
public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter number of elements: ");
    int n = sc.nextInt();
    int[] arr = new int[n];

    System.out.println("Enter " + n + " elements:");
    for (int i = 0; i < n; i++)
        arr[i] = sc.nextInt();
```

* Takes `n` as input.
* Reads `n` integers into `arr`.

Then makes **copies** of array so both versions work on the same data:

```java
int[] arr1 = Arrays.copyOf(arr, n);
int[] arr2 = Arrays.copyOf(arr, n);
```

---

### Timing part

```java
long start1 = System.nanoTime();
deterministicQuickSort(arr1, 0, n - 1);
long end1 = System.nanoTime();
long time1 = end1 - start1;

long start2 = System.nanoTime();
randomizedQuickSort(arr2, 0, n - 1);
long end2 = System.nanoTime();
long time2 = end2 - start2;
```

* Measures execution time using `System.nanoTime()`.
* Time difference gives you sorting time in nanoseconds for each version.
* This helps in **experimental analysis** â€” seeing how randomization affects runtime on same data.

---

### Output part

```java
System.out.println("\nSorted Array (Deterministic Quick Sort):");
printArray(arr1);
System.out.println("Time taken (ns): " + time1);

System.out.println("\nSorted Array (Randomized Quick Sort):");
printArray(arr2);
System.out.println("Time taken (ns): " + time2);
```

Prints sorted arrays and time taken for each.

---

## ğŸ§  Summary of logic flow

```
MAIN â†’
   read array
   copy to arr1 & arr2
   deterministicQuickSort(arr1)
   randomizedQuickSort(arr2)
   print results & timings

deterministicQuickSort() â†’
   partition() â†’
       rearrange based on pivot
       recursively sort left and right

randomizedQuickSort() â†’
   randomizedPartition() â†’
       choose random pivot
       swap it to end
       call partition()
```

---

## âš™ï¸ Final notes (for understanding)

* **Both algorithms produce identical sorted output**.
  The only difference is how pivot is chosen.
* **Randomized version** avoids the bad case where you always pick the worst pivot.
* The **measured times** will vary slightly each run, especially for small inputs.
* In large arrays or sorted inputs, **randomized** will often be faster or more consistent.

---

Would you like me to explain next how to **analyze performance results** (like how to interpret timing, expected vs. worst case, or how to visualize recursion steps)?
